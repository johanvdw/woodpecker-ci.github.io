"use strict";(self.webpackChunkwoodpecker=self.webpackChunkwoodpecker||[]).push([[3671],{82006:e=>{e.exports=JSON.parse('[{"name":"Git Clone","url":"https://github.com/woodpecker-ci/plugin-git","icon":"https://woodpecker-ci.org/img/logo.svg","description":"This is the default plugin for the clone step.","docs":"<p>This plugin is automatically introduced into your pipeline as the first step.\\nIts purpose is to clone your Git repository.</p>\\n<h2 id=\\"features\\">Features</h2>\\n<ul>\\n<li>Git LFS support is enabled by default.</li>\\n<li>Fetch tags when needed.</li>\\n<li>Ajust submodules.</li>\\n</ul>\\n<h2 id=\\"overriding-settings\\">Overriding Settings</h2>\\n<p>You can manually define your <code>clone</code> step in order to change plugin or override some of the default settings.\\nConsult <a href=\\"https://woodpecker-ci.org/docs/usage/pipeline-syntax#clone\\">the <code>clone</code> section of the pipeline documentation</a> for more information;\\nthis documentation page only describes this plugin.</p>\\n<pre><code class=\\"language-yaml\\">clone:\\n  git:\\n    image: woodpeckerci/plugin-git\\n    settings:\\n      depth: 50\\n      lfs: false\\n</code></pre>\\n<h2 id=\\"settings\\">Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>depth</code></td>\\n<td><em>none</em></td>\\n<td>If specified, uses git&#39;s <code>--depth</code> option to create a shallow clone with a limited number of commits, overwritten by partial</td>\\n</tr>\\n<tr>\\n<td><code>lfs</code></td>\\n<td><code>true</code></td>\\n<td>Set this to <code>false</code> to disable retrieval of LFS files</td>\\n</tr>\\n<tr>\\n<td><code>recursive</code></td>\\n<td><code>false</code></td>\\n<td>Clones submodules recursively</td>\\n</tr>\\n<tr>\\n<td><code>skip_verify</code></td>\\n<td><code>false</code></td>\\n<td>Skips the SSL verification</td>\\n</tr>\\n<tr>\\n<td><code>tags</code></td>\\n<td><code>false</code> (except on tag event)</td>\\n<td>Fetches tags when set to true, default is false if event is not tag else true</td>\\n</tr>\\n<tr>\\n<td><code>submodule_overrides</code></td>\\n<td><em>none</em></td>\\n<td>Override submodule urls</td>\\n</tr>\\n<tr>\\n<td><code>submodule_update_remote</code></td>\\n<td><code>false</code></td>\\n<td>Pass the --remote flag to git submodule update</td>\\n</tr>\\n<tr>\\n<td><code>custom_ssl_path</code></td>\\n<td><em>none</em></td>\\n<td>Set path to custom cert</td>\\n</tr>\\n<tr>\\n<td><code>custom_ssl_url</code></td>\\n<td><em>none</em></td>\\n<td>Set url to custom cert</td>\\n</tr>\\n<tr>\\n<td><code>backoff</code></td>\\n<td><code>5sec</code></td>\\n<td>Change backoff duration</td>\\n</tr>\\n<tr>\\n<td><code>attempts</code></td>\\n<td><code>5</code></td>\\n<td>Change backoff attempts</td>\\n</tr>\\n<tr>\\n<td><code>branch</code></td>\\n<td>$CI_COMMIT_BRANCH</td>\\n<td>Change branch name to checkout to</td>\\n</tr>\\n<tr>\\n<td><code>partial</code></td>\\n<td><code>true</code> (except if tags are fetched)</td>\\n<td>Only fetch the one commit and it&#39;s blob objects to resolve all files, overwrite depth with 1</td>\\n</tr>\\n<tr>\\n<td><code>home</code></td>\\n<td></td>\\n<td>Change HOME var for commands executed, fail if it does not exist</td>\\n</tr>\\n</tbody></table>\\n","tags":["git","clone"],"containerImage":"woodpeckerci/plugin-git","containerImageUrl":"https://hub.docker.com/r/woodpeckerci/plugin-git","verified":true},{"name":"Codecov","url":"https://github.com/woodpecker-ci/plugin-codecov","icon":"https://woodpecker-ci.org/img/logo.svg","description":"Plugin to upload coverage reports to Codecov.io.","docs":"<p>The Codecov plugin uploads coverage reports in one of the <a href=\\"https://docs.codecov.com/docs/supported-report-formats\\">supported formats</a> to <a href=\\"https://about.codecov.io/\\">Codecov.io</a>.</p>\\n<h2 id=\\"usage\\">Usage</h2>\\n<p>To use the plugin add a step similar to the following one to your Woodpecker pipeline config:</p>\\n<pre><code class=\\"language-yml\\">pipeline:\\n  codecov:\\n    image: woodpeckerci/plugin-codecov\\n    settings:\\n      files:\\n        - my-coverage-report-output.out\\n        - another-coverage-report.json\\n      token:\\n        from_secret: codecov_token\\n</code></pre>\\n","tags":["coverage","testing"],"containerImage":"woodpeckerci/plugin-codecov","containerImageUrl":"https://hub.docker.com/r/woodpeckerci/plugin-codecov","verified":true},{"name":"Surge preview plugin","url":"https://github.com/woodpecker-ci/plugin-surge-preview","icon":"https://woodpecker-ci.org/img/logo.svg","description":"Plugin to create static pages deployments as preview environments on pull-requests.","docs":"<p>The surge-preview plugin uploads a files of a directory to the CDN of <a href=\\"https://surge.sh/\\">surge.sh</a> it automatically generates an url and posts the status of the deployment with an url as a comment to the pull-request. After closing a pull-request it automatically destroys the preview environment again.</p>\\n<h2 id=\\"usage\\">Usage</h2>\\n<p>To use the plugin add a step similar to the following one to your Woodpecker pipeline config:</p>\\n<pre><code class=\\"language-yml\\">pipeline:\\n  preview:\\n    image: woodpeckerci/plugin-surge-preview\\n    settings:\\n      path: dist/ # path to directory to publish files from\\n      surge_token: xxx # install surge cli and run `surge token`: https://surge.sh/help/getting-started-with-surge\\n      forge_type: github # or gitea, gitlab, ...\\n      forge_url: https://github.com # or https://codeberg.org, https://gitlab.com, ...\\n      forge_repo_token: xxx # access token for your forge\\n    when:\\n      event: pull_request\\n</code></pre>\\n","tags":["publish","cdn","preview"],"containerImage":"woodpeckerci/plugin-surge-preview","containerImageUrl":"https://hub.docker.com/r/woodpeckerci/plugin-surge-preview","verified":true},{"name":"S3 Plugin","url":"https://github.com/woodpecker-ci/plugin-s3","icon":"https://woodpecker-ci.org/img/logo.svg","description":"Plugin to publish files and artifacts to Amazon S3 or Minio.","docs":"<p>The S3 plugin uploads files and build artifacts to your S3 bucket, or S3-compatible bucket such as Minio.\\nThe below pipeline configuration demonstrates simple usage:</p>\\n<pre><code class=\\"language-yml\\">pipeline:\\n  upload:\\n    image: woodpeckerci/plugin-s3\\n    settings:\\n      bucket: my-bucket-name\\n      access_key: a50d28f4dd477bc184fbd10b376de753\\n      secret_key: ****************************************\\n      source: public/**/*\\n      target: /target/location\\n</code></pre>\\n<p>Source the aws credentials from secrets:</p>\\n<pre><code class=\\"language-yml\\">pipeline:\\n  upload:\\n    image: woodpeckerci/plugin-s3\\n    settings:\\n      bucket: my-bucket-name\\n      access_key:\\n        from_secret: aws_access_key_id\\n      secret_key:\\n        from_secret: aws_secret_access_key\\n      source: public/**/*\\n      target: /target/location\\n</code></pre>\\n<p>Use the build number in the S3 target prefix:</p>\\n<pre><code class=\\"language-yml\\">pipeline:\\n  upload:\\n    image: woodpeckerci/plugin-s3\\n    settings:\\n      bucket: my-bucket-name\\n      source: public/**/*\\n      target: /target/location/${CI_BUILD_NUMBER}\\n</code></pre>\\n<p>Override the default acl and region:</p>\\n<pre><code class=\\"language-yml\\">steps:\\n- name: upload\\n  image: woodpeckerci/plugin-s3\\n  settings:\\n    bucket: my-bucket-name\\n    acl: public-read\\n    region: us-east-1\\n    source: public/**/*\\n    target: /target/location\\n</code></pre>\\n<p>Configure the plugin to strip path prefixes when uploading:</p>\\n<pre><code class=\\"language-yml\\">pipeline:\\n  upload:\\n    image: woodpeckerci/plugin-s3\\n    settings:\\n      bucket: my-bucket-name\\n      source: public/**/*\\n      target: /target/location\\n      strip_prefix: public/\\n</code></pre>\\n<p>Configure the plugin to exclude files from upload:</p>\\n<pre><code class=\\"language-yml\\">pipeline:\\n  upload:\\n    image: woodpeckerci/plugin-s3\\n    settings:\\n      bucket: my-bucket-name\\n      source: public/**/*\\n      target: /target/location\\n      exclude:\\n        - **/*.xml\\n</code></pre>\\n<p>Configure the plugin to connect to a Minio server:</p>\\n<pre><code class=\\"language-yml\\">pipeline:\\n  upload:\\n    image: woodpeckerci/plugin-s3\\n    settings:\\n      bucket: my-bucket-name\\n      source: public/**/*\\n      target: /target/location\\n      path_style: true\\n      endpoint: https://play.minio.io:9000\\n</code></pre>\\n<h1 id=\\"parameter-reference\\">Parameter Reference</h1>\\n<p>endpoint\\n: custom endpoint URL (optional, to use a S3 compatible non-Amazon service)</p>\\n<p>access_key\\n: amazon key (optional)</p>\\n<p>secret_key\\n: amazon secret key (optional)</p>\\n<p>bucket\\n: bucket name</p>\\n<p>region\\n: bucket region (<code>us-east-1</code>, <code>eu-west-1</code>, etc)</p>\\n<p>acl\\n: access to files that are uploaded (<code>private</code>, <code>public-read</code>, etc)</p>\\n<p>source\\n: source location of the files, using a glob matching pattern. Location must be within the woodpecker workspace.</p>\\n<p>target\\n: target location of files in the bucket</p>\\n<p>encryption\\n: if provided, use server-side encryption</p>\\n<p>strip_prefix\\n: strip the prefix from source path</p>\\n<p>exclude\\n: glob exclusion patterns</p>\\n<p>path_style\\n: whether path style URLs should be used (true for minio)</p>\\n","tags":["publish","s3","amazon","minio","storage"],"containerImage":"woodpeckerci/plugin-s3","containerImageUrl":"https://hub.docker.com/r/woodpeckerci/plugin-s3","verified":true},{"name":"Gitea Comment","url":"https://github.com/markopolo123/gitea-comment-plugin","description":"Plugin to add comments to a Gitea Pull Request","docs":"<p>A Woodpecker plugin to post comments onto a Gitea Pull Request.</p>\\n<h2 id=\\"usage\\">Usage</h2>\\n<p>Example pipeline:</p>\\n<pre><code class=\\"language-yaml\\">pipeline:\\n  comment:\\n    image: mcs94/gitea-comment\\n    settings:\\n      gitea_address: https://gitea.url.goes.here\\n      gitea_token:\\n        from_secret: gitea_token\\n      comment: &gt;\\n        \u2705 Build ${CI_BUILD_EVENT} of `${CI_REPO_NAME}` has status `${CI_BUILD_STATUS}`.\\n\\n        \ud83d\udcdd Commit by ${CI_COMMIT_AUTHOR} on `${CI_COMMIT_BRANCH}`:\\n\\n        `${CI_COMMIT_MESSAGE}`\\n\\n        \ud83c\udf10 ${CI_BUILD_LINK}\\n    when:\\n      event: [pull_request]\\n</code></pre>\\n<h2 id=\\"settings\\">Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Name</th>\\n<th>Description</th>\\n<th>Default</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>gitea_address</code></td>\\n<td>URL for your gitea instance</td>\\n<td>none</td>\\n</tr>\\n<tr>\\n<td><code>gitea_token</code></td>\\n<td>Gitea API token</td>\\n<td>none</td>\\n</tr>\\n<tr>\\n<td><code>comment</code></td>\\n<td>comment to add to Pull Request</td>\\n<td>none</td>\\n</tr>\\n</tbody></table>\\n","tags":["Gitea","comment"],"containerImage":"mcs94/gitea-comment","containerImageUrl":"https://hub.docker.com/r/mcs94/gitea-comment","verified":false},{"name":"Git Push","url":"https://github.com/appleboy/drone-git-push","icon":"https://raw.githubusercontent.com/appleboy/drone-git-push/master/images/logo.svg","description":"Commit and push to an git repo via SSH","docs":"<p>Use this plugin for commit and push an git repo.\\nYou will need to supply Drone / Woodpecker with a private SSH key or use the same credentials as the cloned repo to being able to push changes.</p>\\n<pre><code class=\\"language-yaml\\">- name: push commit\\n  image: appleboy/drone-git-push\\n  settings:\\n    branch: master\\n    remote: ssh://git@git.heroku.com/falling-wind-1624.git\\n    force: false\\n    commit: true\\n</code></pre>\\n<p>An example of pushing a branch back to the current repository:</p>\\n<pre><code class=\\"language-yaml\\">- name: push commit\\n  image: appleboy/drone-git-push\\n  settings:\\n    remote_name: origin\\n    branch: gh-pages\\n    local_ref: gh-pages\\n</code></pre>\\n<p>An example of specifying the path to a repo:</p>\\n<pre><code class=\\"language-yaml\\">- name: push commit\\n  image: appleboy/drone-git-push\\n  settings:\\n    remote_name: origin\\n    branch: gh-pages\\n    local_ref: gh-pages\\n    path: path/to/repo\\n</code></pre>\\n<h2 id=\\"parameter-reference\\">Parameter Reference</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>setting</th>\\n<th>description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td>ssh_key</td>\\n<td>private SSH key for the remote machine</td>\\n</tr>\\n<tr>\\n<td>remote</td>\\n<td>target remote repository (if blank, assume exists)</td>\\n</tr>\\n<tr>\\n<td>remote_name</td>\\n<td>name of the remote to use locally (default &quot;deploy&quot;)</td>\\n</tr>\\n<tr>\\n<td>branch</td>\\n<td>target remote branch, defaults to master</td>\\n</tr>\\n<tr>\\n<td>local_branch</td>\\n<td>local branch or ref to push (default &quot;HEAD&quot;)</td>\\n</tr>\\n<tr>\\n<td>path</td>\\n<td>path to git repo (if blank, assume current directory)</td>\\n</tr>\\n<tr>\\n<td>force</td>\\n<td>force push using the <code>--force</code> flag, defaults to false</td>\\n</tr>\\n<tr>\\n<td>skip_verify</td>\\n<td>skip verification of HTTPS certs, defaults to false</td>\\n</tr>\\n<tr>\\n<td>commit</td>\\n<td>add and commit the contents of the repo before pushing, defaults to false</td>\\n</tr>\\n<tr>\\n<td>commit_message</td>\\n<td>add a custom message for commit, if it is omitted, it will be <code>[skip ci] Commit dirty state</code></td>\\n</tr>\\n<tr>\\n<td>empty_commit</td>\\n<td>if you only want generate an empty commit, you can do it using this option</td>\\n</tr>\\n<tr>\\n<td>tag</td>\\n<td>if you want to add a tag to the commit, you can do it using this option. You must also set <code>followtags</code> to <code>true</code> if you want the tag to be pushed to the remote</td>\\n</tr>\\n<tr>\\n<td>author_name</td>\\n<td>the name to use for the author of the commit (if blank, assume push commiter name)</td>\\n</tr>\\n<tr>\\n<td>author_email</td>\\n<td>the email address to use for the author of the commit (if blank, assume push commiter name)</td>\\n</tr>\\n<tr>\\n<td>followtags</td>\\n<td>push with --follow-tags option</td>\\n</tr>\\n<tr>\\n<td>rebase</td>\\n<td>pull --rebase before pushing</td>\\n</tr>\\n</tbody></table>\\n","tags":["deploy","publish","git-push"],"author":"appleboy","containerImage":"appleboy/drone-git-push","containerImageUrl":"https://hub.docker.com/r/appleboy/drone-git-push","verified":false},{"name":"WebDAV","url":"https://github.com/vividboarder/drone-webdav","description":"plugin to publish any artifacts to any WebDAV server","docs":"<p>A <a href=\\"https://www.drone.io/\\">Drone CI</a> / <a href=\\"https://woodpecker-ci.org/\\">Woodpecker CI</a> plugin,\\nthat will allow pushing build artifacts to any <a href=\\"http://www.webdav.org/\\">WebDAV</a> server, including Nextcloud or ownCloud.</p>\\n<h2 id=\\"features\\">Features</h2>\\n<ul>\\n<li>Upload multiple files</li>\\n<li>Use a proxy</li>\\n<li>Retry on fail</li>\\n</ul>\\n<h2 id=\\"settings\\">Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings Name</th>\\n<th>Required</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>file</code></td>\\n<td><strong>\u2713</strong></td>\\n<td>File(s) to upload. Use <a href=\\"https://curl.se/docs/manpage.html#-T\\">curl syntax</a> for multiple (e.g. <code>{dogs.png,cats.jpg}</code>)</td>\\n</tr>\\n<tr>\\n<td><code>destination</code></td>\\n<td><strong>\u2713</strong></td>\\n<td>The WebDav <strong>folder</strong> url</td>\\n</tr>\\n<tr>\\n<td><code>username</code></td>\\n<td><strong>\u2713</strong></td>\\n<td>The WebDav-<strong>User</strong> to use</td>\\n</tr>\\n<tr>\\n<td><code>password</code></td>\\n<td></td>\\n<td>The <strong>Password</strong> for the WebDav-User</td>\\n</tr>\\n<tr>\\n<td><code>proxy_url</code></td>\\n<td></td>\\n<td>May be used to specify a proxy (e.g. <code>socks5://{ip_address}:{port}</code></td>\\n</tr>\\n<tr>\\n<td><code>timeout</code></td>\\n<td></td>\\n<td>Defines a timeout (in seconds) to stop the upload after a certain time</td>\\n</tr>\\n<tr>\\n<td><code>attempts</code></td>\\n<td></td>\\n<td>Defines how often a failed upload should be retried. Normally there is only one upload attempt</td>\\n</tr>\\n<tr>\\n<td><code>custom_arguments</code></td>\\n<td></td>\\n<td>Additional arguments to be passed to <a href=\\"https://curl.se/\\"><code>curl</code></a></td>\\n</tr>\\n</tbody></table>\\n<h2 id=\\"example\\">Example</h2>\\n<pre><code class=\\"language-yaml\\">pipeline:\\n  upload_debug:\\n    image: vividboarder/drone-webdav\\n    settings:\\n      file: com.vividboarder.otbeta/build/outputs/apk/com.vividboarder.otbeta-debug.apk\\n      destination: https://my.nextcloud.com/remote.php/dav/files/vividboarder/Android/Apks/\\n      username:\\n        from_secret: WEBDAV_USER\\n      password:\\n        from_secret: WEBDAV_PASSWORD\\n</code></pre>\\n","tags":["deploy","publish"],"containerImage":"vividboarder/drone-webdav","containerImageUrl":"https://hub.docker.com/r/vividboarder/drone-webdav","verified":false},{"name":"Aptly","url":"https://gitea.zionetrix.net/bn8/aptly-publish","icon":"https://www.aptly.info/img/logo.svg","description":"plugin to publish Debian package on a Aptly repository","docs":"<p>Woodpecker CI plugin to publish one (or more) Debian package on a Aptly repository using its API.</p>\\n<h2 id=\\"features\\">Features</h2>\\n<p>This plugin will try to :</p>\\n<ul>\\n<li>List all changes files in the specified directory and filter on the specified source package name (if specified)</li>\\n<li>Iter on detected changes files and foreach of then:</li>\\n<li>the changes file is parsed to detect the source package name, the distribution and included files</li>\\n<li>the repository name is computed (if not specified). <strong>Format:</strong> <code>{prefix}_{distribution}_{component}</code>. <strong>Note:</strong> if the default prefix is specified (<code>.</code>), it will not be used to compute the repository name.</li>\\n<li>the current published distribution is retreived using APTLY Publish API to:<ul>\\n<li>check it was already manally published a first time</li>\\n<li>check it used a snapshot kind of sources</li>\\n<li>retreive other components source snapshot</li>\\n</ul>\\n</li>\\n<li>Upload the changes file and all its included files using APTLY File Upload API in a directory named as the source package</li>\\n<li>Include the changes file using APTLY Local Repos API</li>\\n<li>Compute a snapshot name for the repository based on the current date and the repository name. <strong>Format:</strong> <code>YYYYMMDD-HHMMSS_{repository name}</code></li>\\n<li>Create a snapshot of the repository using APTLY Local Repos API</li>\\n<li>Update the published distribution with this new snapshot as source of the specified component and keeping other components source snapshot.</li>\\n</ul>\\n<p>In case of error, it will exit with a detailed error message (within the limits of what is provided by the Aptly API).</p>\\n<h2 id=\\"settings\\">Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>api_url</code></td>\\n<td><em>none</em></td>\\n<td>Your Aptly API URL (required)</td>\\n</tr>\\n<tr>\\n<td><code>api_username</code></td>\\n<td><em>none</em></td>\\n<td>Username to authenticate on your Aptly API (required)</td>\\n</tr>\\n<tr>\\n<td><code>api_password</code></td>\\n<td><em>none</em></td>\\n<td>Password to authenticate on your Aptly API (required)</td>\\n</tr>\\n<tr>\\n<td><code>prefix</code></td>\\n<td><code>.</code></td>\\n<td>The publishing prefix</td>\\n</tr>\\n<tr>\\n<td><code>repo_component</code></td>\\n<td><code>main</code></td>\\n<td>The component name to publish on</td>\\n</tr>\\n<tr>\\n<td><code>repo_name</code></td>\\n<td><code>{prefix}_{distribution}_{component}</code></td>\\n<td>The repository name to publish on. If not specified, it will be computed using the specified prefix and component and the detected package distribution. See above for details.</td>\\n</tr>\\n<tr>\\n<td><code>path</code></td>\\n<td><code>dist</code></td>\\n<td>Path to the directory where files to publish are stored</td>\\n</tr>\\n<tr>\\n<td><code>source_name</code></td>\\n<td><em>none</em></td>\\n<td>Name of the source package to publish (optional, default: all <code>changes</code> files are will be publish)</td>\\n</tr>\\n<tr>\\n<td><code>max_retries</code></td>\\n<td><em>none</em></td>\\n<td>The number of retry in case of error calling the Aptly API (optional, default: no retry)</td>\\n</tr>\\n</tbody></table>\\n<h2 id=\\"example\\">Example</h2>\\n<pre><code class=\\"language-yaml\\">pipeline:\\n  publish:\\n    image: brenard/aptly-publish\\n    settings:\\n      api_url: https://your.aptly.tld/api\\n      api_username: myproject\\n      api_password:\\n        from_secret: aptly_api_password\\n      prefix: debian\\n      repo_component: main\\n      repo_name: debian_stable_main\\n      path: dist\\n      source_name: myproject\\n      max_retries: 2\\n</code></pre>\\n","tags":["APT","aptly","publish"],"containerImage":"brenard/aptly-publish","containerImageUrl":"https://hub.docker.com/r/brenard/aptly-publish","verified":false},{"name":"Woodpecker Email","url":"https://gitnet.fr/deblan/woodpecker-email","icon":"https://gitnet.fr/deblan/woodpecker-email/raw/branch/develop/logo.svg","description":"plugin to send build status notifications via Email.","docs":"<p>Use the Email plugin for sending build status notifications via email.</p>\\n<h2 id=\\"config\\">Config</h2>\\n<p>You can configure the plugin using the following parameters:</p>\\n<ul>\\n<li><strong>from.address</strong> - Send notifications from this address</li>\\n<li><strong>from.name</strong> - Notifications sender name</li>\\n<li><strong>host</strong> - SMTP server host</li>\\n<li><strong>port</strong> - SMTP server port, defaults to <code>587</code></li>\\n<li><strong>username</strong> - SMTP username</li>\\n<li><strong>password</strong> - SMTP password</li>\\n<li><strong>skip_verify</strong> - Skip verification of SSL certificates, defaults to <code>false</code></li>\\n<li><strong>no_starttls</strong> - Enable/Disable STARTTLS</li>\\n<li><strong>recipients</strong> - List of recipients to send this mail to (besides the commit author)</li>\\n<li><strong>recipients_file</strong> - Filename to load additional recipients from (textfile with one email per line) (besides the commit author)</li>\\n<li><strong>recipients_only</strong> - Do not send mails to the commit author, but only to <strong>recipients</strong>, defaults to <code>false</code></li>\\n<li><strong>subject</strong> - The subject line template</li>\\n<li><strong>body</strong> - The email body template</li>\\n<li><strong>attachment</strong> - An optional file to attach to the sent mail(s), can be an absolute path or relative to the working directory.</li>\\n<li><strong>evaluate</strong> - An optional expression to evaluate (on the fly) whether the mail should be sent or not (<a href=\\"https://woodpecker-ci.org/docs/next/usage/pipeline-syntax#evaluate\\">https://woodpecker-ci.org/docs/next/usage/pipeline-syntax#evaluate</a>).</li>\\n</ul>\\n<h2 id=\\"example\\">Example</h2>\\n<p>The following is a sample configuration in your .woodpecker.yml file:</p>\\n<pre><code class=\\"language-yaml\\">pipeline:\\n  mail:\\n    image: deblan/woodpecker-email\\n    settings:\\n      from.address: noreply@github.com\\n      from.name: John Smith\\n      host: smtp.mailgun.org\\n      username: octocat\\n      password: 12345\\n      recipients:\\n        - octocat@github.com\\n</code></pre>\\n<h3 id=\\"secrets\\">Secrets</h3>\\n<p>The Email plugin supports reading credentials and other parameters from the Drone secret store. This is strongly recommended instead of storing credentials in the pipeline configuration in plain text.</p>\\n<pre><code class=\\"language-diff\\">pipeline:\\n  mail:\\n    image: deblan/woodpecker-email\\n    settings:\\n      from.address: noreply@github.com\\n      host: smtp.mailgun.org\\n+     username:\\n+       from_secret: email_username\\n+     password: 12345\\n+       from_secret: email_password\\n      recipients:\\n        - octocat@github.com\\n</code></pre>\\n<h3 id=\\"evaluation\\">Evaluation</h3>\\n<p>This plugin introduces an optional expression to evaluate (on the fly) whether the mail should be sent or not.</p>\\n<pre><code class=\\"language-diff\\">pipeline:\\n  mail:\\n    image: deblan/woodpecker-email\\n    settings:\\n      ...\\n    when:\\n      - evaluate: &#39;CI_STEP_STATUS == &quot;failure&quot; || CI_PREV_PIPELINE_STATUS == &quot;failure&quot;&#39;\\n</code></pre>\\n<p>The problem is that the expression is evaluated before the pipeline is generated. In this case, <code>CI_STEP_STATUS</code> does not exist yet and the mail step is ignored unless the previous pipeline failed.</p>\\n<pre><code class=\\"language-diff\\">pipeline:\\n  mail:\\n    image: deblan/woodpecker-email\\n    settings:\\n      ...\\n+     evaluate: &#39;CI_STEP_STATUS == &quot;failure&quot; || CI_PREV_PIPELINE_STATUS == &quot;failure&quot;&#39;\\n    when:\\n-     - evaluate: &#39;CI_STEP_STATUS == &quot;failure&quot; || CI_PREV_PIPELINE_STATUS == &quot;failure&quot;&#39;\\n</code></pre>\\n<p>More information about the syntaxe on (<a href=\\"https://woodpecker-ci.org/docs/next/usage/pipeline-syntax#evaluate\\">https://woodpecker-ci.org/docs/next/usage/pipeline-syntax#evaluate</a>).</p>\\n<h3 id=\\"custom-templates\\">Custom Templates</h3>\\n<p>In some cases you may want to customize the look and feel of the email message\\nso you can use custom templates. For the use case we expose the following\\nadditional parameters, all of the accept a custom handlebars template, directly\\nprovided as a string or as a remote URL which gets fetched and parsed:</p>\\n<ul>\\n<li><strong>subject</strong> - A handlebars template to create a custom subject. For more\\ndetails take a look at the <a href=\\"http://handlebarsjs.com/\\">docs</a>. You can see the\\ndefault template <a href=\\"https://github.com/Drillster/drone-email/blob/master/defaults.go#L14\\">here</a></li>\\n<li><strong>body</strong> - A handlebars template to create a custom template. For more\\ndetails take a look at the <a href=\\"http://handlebarsjs.com/\\">docs</a>. You can see the\\ndefault template <a href=\\"https://github.com/Drillster/drone-email/blob/master/defaults.go#L19-L267\\">here</a></li>\\n</ul>\\n<p>Example configuration that generate a custom email:</p>\\n<pre><code class=\\"language-yaml\\">pipeline:\\n  mail:\\n    image: deblan/woodpecker-email\\n    settings:\\n      from.address: noreply@github.com\\n      host: smtp.mailgun.org\\n      username: octocat\\n      password: 12345\\n      subject: &gt;\\n        [{{ build.status }}]\\n        {{ repo.owner }}/{{ repo.name }}\\n        ({{ build.branch }} - {{ truncate build.commit 8 }})\\n      body:\\n        https://git.io/vgvPz\\n</code></pre>\\n<h3 id=\\"skip-ssl-verify\\">Skip SSL verify</h3>\\n<p>In some cases you may want to skip SSL verification, even if we discourage that\\nas it leads to an unsecure environment. Please use this option only within your\\nintranet and/or with truested resources. For this use case we expose the\\nfollowing additional parameter:</p>\\n<ul>\\n<li><strong>skip_verify</strong> - Skip verification of SSL certificates</li>\\n</ul>\\n<p>Example configuration that skips SSL verification:</p>\\n<pre><code class=\\"language-diff\\">pipeline:\\n  mail:\\n    image: deblan/woodpecker-email\\n    settings:\\n      from: noreply@github.com\\n      host: smtp.mailgun.org\\n      username: octocat\\n      password: 12345\\n+     skip_verify: true\\n</code></pre>\\n<h3 id=\\"starttls\\">STARTTLS</h3>\\n<p>By default, STARTTLS is being used opportunistically meaning, if advertised\\nby the server, traffic is going to be encrypted.</p>\\n<p>You may want to disable STARTTLS, e.g., with faulty and/or internal servers:</p>\\n<pre><code class=\\"language-diff\\">pipeline:\\n  mail:\\n    image: deblan/woodpecker-email\\n    settings:\\n      from: noreply@github.com\\n      host: smtp.mailgun.org\\n      username: octocat\\n      password: 12345\\n+     no_starttls: true\\n</code></pre>\\n","tags":["notifications","email"],"containerImage":"deblan/woodpecker-email","containerImageUrl":"https://hub.docker.com/r/deblan/woodpecker-email","verified":false},{"name":"Woodpecker Feishu Bot","url":"https://github.com/wenerme/wode/tree/main/apps/woodpecker-feishu-bot","description":"Send notify to feishu/\u98de\u4e66 in text or markdown format","docs":"<h2 id=\\"example\\">Example</h2>\\n<pre><code class=\\"language-yaml\\">variables:\\n  - &amp;notify_image &#39;wener/woodpecker-feishu-bot&#39;\\n\\npipeline:\\n  Notify Start:\\n    image: *notify_image\\n    settings:\\n      feishu_bot_url:\\n        from_secret: feishu_bot_url\\n      feishu_bot_secret:\\n        from_secret: feishu_bot_secret\\n      markdown: |\\n        \ud83c\udfd7\ufe0f Start building &lt;%= env.CI_REPO_NAME %&gt; #&lt;%= env.CI_BUILD_NUMBER %&gt;\\n\\n        - &lt;%= $.link(env.CI_COMMIT,env.CI_COMMIT_LINK) %&gt; &lt;%=env.CI_COMMIT_MESSAGE.replaceAll(/\\\\n/g,&#39;;&#39;)%&gt;\\n\\n        \ud83d\udce6\ufe0f &lt;%=$.link(env.CI_REPO_NAME,env.CI_BUILD_LINK)%&gt;\\n\\n  # Do the real work\\n\\n  Notify Done:\\n    image: *notify_image\\n    settings:\\n      feishu_bot_url:\\n        from_secret: feishu_bot_url\\n      feishu_bot_secret:\\n        from_secret: feishu_bot_secret\\n      markdown: |\\n        &lt;%= env.CI_PIPELINE_STATUS === &#39;success&#39; ? &#39;\u2705&#39; : &#39;\u274c&#39; %&gt; Building complete &lt;%= env.CI_REPO_NAME %&gt; #&lt;%= env.CI_BUILD_NUMBER %&gt;\\n\\n        - &lt;%= env.CI_COMMIT_MESSAGE %&gt;\\n\\n        \ud83d\udce6\ufe0f &lt;%= $.link(env.CI_REPO_NAME, env.CI_BUILD_LINK) %&gt; \xb7 \u23f3&lt;%= env.CI_PIPELINE_FINISHED - env.CI_PIPELINE_STARTED %&gt;\\n    when:\\n      status: [ success, failure ]\\n</code></pre>\\n<h2 id=\\"settings\\">settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>setting</th>\\n<th>for</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td>feisbu_bot_url</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>feisbu_bot_secret</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>content</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>format</td>\\n<td>format of content, default to markdown</td>\\n</tr>\\n<tr>\\n<td>markdown</td>\\n<td>=content+format=markdown</td>\\n</tr>\\n<tr>\\n<td>text</td>\\n<td>=content+format=text</td>\\n</tr>\\n<tr>\\n<td>dry_run</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>debug</td>\\n<td>print env</td>\\n</tr>\\n<tr>\\n<td>template</td>\\n<td>render as eta template, default to true</td>\\n</tr>\\n<tr>\\n<td>failsafe</td>\\n<td>if true, ignore error</td>\\n</tr>\\n</tbody></table>\\n<ul>\\n<li>eta template context<ul>\\n<li>env -&gt; process.env</li>\\n<li>fs -&gt; fs-extra</li>\\n</ul>\\n</li>\\n</ul>\\n","tags":["notify"],"containerImage":"wener/woodpecker-feishu-bot","containerImageUrl":"https://hub.docker.com/r/wener/woodpecker-feishu-bot","verified":false},{"name":"Nextcloud Upload","url":"https://github.com/Ellpeck/WoodpeckerPlugins/tree/main/nextcloud-upload","description":"Upload files to Nextcloud using chunking and optionally add tags to files","docs":"<h1 id=\\"nextcloud-upload\\">Nextcloud Upload</h1>\\n<p>Simple plugin to upload files to Nextcloud using chunking, based on a glob pattern and a destination location. Note that, since this uses Nextcloud&#39;s built-in chunking system, it likely doesn&#39;t work for other WebDAV applications.</p>\\n<p>Here&#39;s an example of how to use it:</p>\\n<pre><code class=\\"language-yml\\">steps:\\n  upload:\\n    image: ellpeck/woodpecker-nextcloud-upload\\n    settings:\\n      # required settings\\n      server: https://cloud.ellpeck.de # the server to use\\n      user: EllBot # the user\\n      token: access-token # the access token, or password if 2FA is disabled\\n      files: # the file(s), uses glob patterns\\n        - &quot;**/*.md&quot;\\n      dest: Uploads/CoolMarkdownFiles # the destination directory\\n\\n      # optional retention settings, useful if old builds should be deleted automatically\\n      retentionamount: 7 # amount of children that retentionbase is allowed to have before oldest ones are deleted on upload\\n      retentionbase: Uploads # directory that the retentionamount applies to\\n      retentionskiptrash: false # whether retention-based deletion should skip the Nextcloud trash, defaults to false\\n\\n      # misc optional settings\\n      basedir: &quot;.&quot; # local base directory for files, defaults to .\\n      chunksize: # chunk size in bytes, defaults to 10485760, or 10 MiB\\n      quiet: false # whether to reduce output, defaults to false\\n      tags: # a set of tags to apply to uploaded files, tag is expected to already exist\\n        - mytag\\n      flatten: false # whether to flatten directories, causing all files to be placed directly in dest, defaults to false\\n</code></pre>\\n","tags":["deploy","publish"],"containerImage":"ellpeck/woodpecker-nextcloud-upload","containerImageUrl":"https://hub.docker.com/r/ellpeck/woodpecker-nextcloud-upload","verified":false},{"name":"Kubernetes Deployment or StatefulSet Update","url":"https://github.com/euryecetelecom/woodpeckerci-kubernetes","description":"Update a Kubernetes deployment or statefulset","docs":"<h1 id=\\"kubernetes-plugin-for-woodpecker-ci\\">Kubernetes plugin for Woodpecker-CI</h1>\\n<p>This plugin allows to update a Kubernetes deployment or statefulset.</p>\\n<h2 id=\\"settings\\">Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Setting Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>kubernetes_server</code></td>\\n<td><em>none</em></td>\\n<td>Kubernetes server to target (ex: <a href=\\"https://mykubernetes.example.com\\">https://mykubernetes.example.com</a>) - mandatory</td>\\n</tr>\\n<tr>\\n<td><code>kubernetes_token</code></td>\\n<td><em>none</em></td>\\n<td>Kubernetes token to use (cf Generating secrets) - mandatory / B64 encoded</td>\\n</tr>\\n<tr>\\n<td><code>kubernetes_cert</code></td>\\n<td><em>none</em></td>\\n<td>Kubernetes certificate to use (cf Generating secrets) / B64 encoded</td>\\n</tr>\\n<tr>\\n<td><code>kubernetes_user</code></td>\\n<td><code>default</code></td>\\n<td>Kubernetes user to use</td>\\n</tr>\\n<tr>\\n<td><code>deployment</code></td>\\n<td><em>none</em></td>\\n<td>Deployment(s) to update - at least 1 deployment or statefulset are mandatory</td>\\n</tr>\\n<tr>\\n<td><code>statefulset</code></td>\\n<td><em>none</em></td>\\n<td>StatefulSet(s) to update - at least 1 deployment or statefulset are mandatory</td>\\n</tr>\\n<tr>\\n<td><code>namespace</code></td>\\n<td><code>default</code></td>\\n<td>Deployment or StatefulSet namespace</td>\\n</tr>\\n<tr>\\n<td><code>repo</code></td>\\n<td><em>none</em></td>\\n<td>Repository containing the image to pull from (ex: myrepo.example.com/project/image) - mandatory</td>\\n</tr>\\n<tr>\\n<td><code>container</code></td>\\n<td><em>none</em></td>\\n<td>Container(s) to update with the image - mandatory</td>\\n</tr>\\n<tr>\\n<td><code>tag</code></td>\\n<td><em>none</em></td>\\n<td>Image tag to pull from - mandatory</td>\\n</tr>\\n<tr>\\n<td><code>wait</code></td>\\n<td><em>none</em></td>\\n<td>Wait for update to be applied (ex: true)</td>\\n</tr>\\n<tr>\\n<td><code>wait_timeout</code></td>\\n<td><code>30s</code></td>\\n<td>Wait timeout</td>\\n</tr>\\n<tr>\\n<td><code>force</code></td>\\n<td><em>none</em></td>\\n<td>Force pull the new image, to ensure an image with the same tag is updated (ex: true)</td>\\n</tr>\\n</tbody></table>\\n<h2 id=\\"usage\\">Usage</h2>\\n<h3 id=\\"update-a-container-from-one-deployment\\">Update a container from one Deployment</h3>\\n<p>This pipeline will update the <code>my-deployment</code> deployment with the image tagged <code>CI_COMMIT_SHA</code></p>\\n<pre><code class=\\"language-yaml\\">    deploy:\\n        image: euryecetelecom/woodpeckerci-kubernetes\\n        settings:\\n            kubernetes_server:\\n                from_secret: kubernetes_server\\n            kubernetes_token:\\n                from_secret: kubernetes_token\\n            kubernetes_cert:\\n                from_secret: kubernetes_cert\\n            namespace: default\\n            deployment: my-deployment\\n            repo: myorg/myrepo\\n            container: my-container\\n            tag: ${CI_COMMIT_BRANCH}\\n        secrets:\\n            - kubernetes_cert\\n            - kubernetes_server\\n            - kubernetes_token\\n</code></pre>\\n<h3 id=\\"update-a-container-from-one-statefulset\\">Update a container from one StatefulSet</h3>\\n<p>This pipeline will update the <code>my-statefulset</code> statefulset with the image tagged <code>CI_COMMIT_SHA</code></p>\\n<pre><code class=\\"language-yaml\\">    deploy:\\n        image: euryecetelecom/woodpeckerci-kubernetes\\n        settings:\\n            kubernetes_server:\\n                from_secret: kubernetes_server\\n            kubernetes_token:\\n                from_secret: kubernetes_token\\n            kubernetes_cert:\\n                from_secret: kubernetes_cert\\n            namespace: default\\n            statefulset: my-statefulset\\n            repo: myorg/myrepo\\n            container: my-container\\n            tag: ${CI_COMMIT_BRANCH}\\n        secrets:\\n            - kubernetes_cert\\n            - kubernetes_server\\n            - kubernetes_token\\n</code></pre>\\n<h3 id=\\"update-a-container-from-one-deployment-force-rollout-and-wait-for-it\\">Update a container from one Deployment, force rollout and wait for it</h3>\\n<p>This pipeline will update the <code>my-deployment</code> deployment with the image tagged <code>CI_COMMIT_SHA</code>, force rollout and wait 300s (default is 30s) for it to be ready. This helps to ensure the next pipeline step is based on the deployed container - for automatic testing purposes for example.</p>\\n<pre><code class=\\"language-yaml\\">    deploy:\\n        image: euryecetelecom/woodpeckerci-kubernetes\\n        settings:\\n            kubernetes_server:\\n                from_secret: kubernetes_server\\n            kubernetes_token:\\n                from_secret: kubernetes_token\\n            kubernetes_cert:\\n                from_secret: kubernetes_cert\\n            namespace: default\\n            wait: true\\n            wait_timeout: 60s\\n            force: true\\n            deployment: my-deployment\\n            repo: myorg/myrepo\\n            container: my-container\\n            tag: ${CI_COMMIT_BRANCH}\\n        secrets:\\n            - kubernetes_cert\\n            - kubernetes_server\\n            - kubernetes_token\\n</code></pre>\\n<h3 id=\\"update-a-container-from-several-deployments\\">Update a container from several Deployments</h3>\\n<p>Deploying containers across several deployments, eg in a scheduler-worker setup. Make sure your container <code>name</code> in your manifest is the same for each pod.</p>\\n<pre><code class=\\"language-yaml\\">    deploy:\\n        image: euryecetelecom/woodpeckerci-kubernetes\\n        settings:\\n            kubernetes_server:\\n                from_secret: kubernetes_server\\n            kubernetes_token:\\n                from_secret: kubernetes_token\\n            kubernetes_cert:\\n                from_secret: kubernetes_cert\\n            namespace: default\\n            deployment: [server-deploy, worker-deploy]\\n            repo: myorg/myrepo\\n            container: my-container\\n            tag: ${CI_COMMIT_BRANCH}\\n        secrets:\\n            - kubernetes_cert\\n            - kubernetes_server\\n            - kubernetes_token\\n</code></pre>\\n<h3 id=\\"update-multiple-container-from-a-deployment\\">Update multiple container from a Deployment</h3>\\n<p>Deploying multiple containers within the same deployment.</p>\\n<pre><code class=\\"language-yaml\\">    deploy:\\n        image: euryecetelecom/woodpeckerci-kubernetes\\n        settings:\\n            kubernetes_server:\\n                from_secret: kubernetes_server\\n            kubernetes_token:\\n                from_secret: kubernetes_token\\n            kubernetes_cert:\\n                from_secret: kubernetes_cert\\n            namespace: default\\n            deployment: my-deployment\\n            repo: myorg/myrepo\\n            container: [container1, container2]\\n            tag: ${CI_COMMIT_BRANCH}\\n        secrets:\\n            - kubernetes_cert\\n            - kubernetes_server\\n            - kubernetes_token\\n</code></pre>\\n<h3 id=\\"todo-to-be-tested---multiple-containers-from-multiple-deployments\\">TODO: To be tested - multiple containers from multiple deployments</h3>\\n<h2 id=\\"required-secrets\\">Required secrets</h2>\\n<pre><code class=\\"language-bash\\">    woodpecker-cli secret add --image=infras/woodpeckerci-kubernetes \\\\\\n        your-org/your-repo KUBERNETES_SERVER https://mykubernetesapiserver\\n\\n    woodpecker-cli secret add --image=infras/woodpeckerci-kubernetes \\\\\\n        your-org/your-repo KUBERNETES_CERT &lt;base64 encoded CA.crt&gt;\\n\\n    woodpecker-cli secret add --image=infras/woodpeckerci-kubernetes \\\\\\n        your-org/your-repo KUBERNETES_TOKEN eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJrdWJ...\\n</code></pre>\\n<p>When using TLS Verification, ensure Server Certificate used by kubernetes API server \\nis signed for SERVER url ( could be a reason for failures if using aliases of kubernetes cluster )</p>\\n<h2 id=\\"generating-secrets---rbac\\">Generating secrets - RBAC</h2>\\n<p>When using a version of kubernetes with RBAC (role-based access control)\\nenabled, you will not be able to use the default service account, since it does\\nnot have access to update deployments.  Instead, you will need to create a\\ncustom service account with the appropriate permissions (<code>Role</code> and <code>RoleBinding</code>, or <code>ClusterRole</code> and <code>ClusterRoleBinding</code> if you need access across namespaces using the same service account).</p>\\n<p>As an example (for the <code>default</code> namespace):</p>\\n<pre><code class=\\"language-yaml\\">apiVersion: v1\\nkind: ServiceAccount\\nmetadata:\\n  name: cicd-deploy\\n  namespace: default\\nautomountServiceAccountToken: true\\n\\n---\\n\\napiVersion: rbac.authorization.k8s.io/v1\\nkind: Role\\nmetadata:\\n  name: cicd-deploy\\n  namespace: default\\nrules:\\n  - apiGroups: [&quot;apps&quot;]\\n    resources: [&quot;deployments&quot;]\\n    verbs: [&quot;get&quot;,&quot;list&quot;,&quot;patch&quot;,&quot;update&quot;, &quot;watch&quot;]\\n\\n---\\n\\napiVersion: rbac.authorization.k8s.io/v1\\nkind: RoleBinding\\nmetadata:\\n  name: cicd-deploy\\n  namespace: default\\nsubjects:\\n  - kind: ServiceAccount\\n    name: cicd-deploy\\n    namespace: default\\nroleRef:\\n  kind: Role\\n  name: cicd-deploy\\n  apiGroup: rbac.authorization.k8s.io\\n\\n---\\n\\napiVersion: v1\\nkind: Secret\\nmetadata:\\n  name: cicd-deploy-secret\\n  namespace: default\\n  annotations:\\n    kubernetes.io/service-account.name: cicd-deploy\\ntype: kubernetes.io/service-account-token\\n</code></pre>\\n<p>Once the service account is created, you can extract the <code>ca.cert</code> and <code>token</code>\\nparameters as mentioned for the default service account above:</p>\\n<pre><code>kubectl -n default get secret/cicd-deploy-secret -o yaml | egrep &#39;ca.crt:|token:&#39;\\n</code></pre>\\n<h2 id=\\"improvements--ideas\\">Improvements / Ideas</h2>\\n<p>Replace the current kubectl bash script with a go implementation.</p>\\n","tags":["deploy","kubernetes","deployment","container","statefulset"],"containerImage":"euryecetelecom/woodpeckerci-kubernetes","containerImageUrl":"https://hub.docker.com/r/euryecetelecom/woodpeckerci-kubernetes","verified":false},{"name":"Dockle plugin for Woodpecker-CI","url":"https://github.com/euryecetelecom/woodpeckerci-kubernetes","description":"Scan containers with dockle","docs":"<h1 id=\\"dockle-plugin-for-woodpecker-ci\\">Dockle plugin for Woodpecker-CI</h1>\\n<p>Woodpecker-CI plugin to scan containers with dockle (Container Image Linter for Security, Helping build the Best-Practice Docker Image) <a href=\\"https://github.com/goodwithtech/dockle\\">https://github.com/goodwithtech/dockle</a>.</p>\\n<h2 id=\\"settings\\">Settings</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>Settings Name</th>\\n<th>Default</th>\\n<th>Description</th>\\n</tr>\\n</thead>\\n<tbody><tr>\\n<td><code>exit-code</code></td>\\n<td><code>1</code></td>\\n<td>If an issue is detected let the step fail</td>\\n</tr>\\n<tr>\\n<td><code>exit-level</code></td>\\n<td><code>warn</code></td>\\n<td>Define alert levels (can be info, warn or fatal)</td>\\n</tr>\\n<tr>\\n<td><code>build-directory</code></td>\\n<td><code>${CI_WORKSPACE}</code></td>\\n<td>Directory containing the Dockerfile to use to build the container</td>\\n</tr>\\n<tr>\\n<td><code>dockerfile</code></td>\\n<td><code>Dockerfile</code></td>\\n<td>Dockerfile to use</td>\\n</tr>\\n<tr>\\n<td><code>dockle-ignores</code></td>\\n<td><em>none</em></td>\\n<td>Dockle rules to ignore (cf <a href=\\"https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md\\">https://github.com/goodwithtech/dockle/blob/master/CHECKPOINT.md</a>)</td>\\n</tr>\\n</tbody></table>\\n<h2 id=\\"usage\\">Usage</h2>\\n<p>This container require privilegied capabilities to communicate with host docker daemon, like woodpeckerci/plugin-docker-buildx. Ensure the project configuration takes it in account (verified has to be enabled).</p>\\n<h3 id=\\"simple-usage\\">Simple usage:</h3>\\n<pre><code class=\\"language-yml\\">pipeline:\\n  dockle_check:\\n    image: euryecetelecom/woodpeckerci-dockle\\n    volumes:\\n      - /var/run/docker.sock:/var/run/docker.sock\\n</code></pre>\\n<h3 id=\\"advanced-usage\\">Advanced usage:</h3>\\n<pre><code class=\\"language-yml\\">pipeline:\\n  dockle_check:\\n    image: euryecetelecom/woodpeckerci-dockle\\n    volumes:\\n      - /var/run/docker.sock:/var/run/docker.sock\\n    settings:\\n      dockerfile: MyCustomDockerfile\\n      build-directory: ./docker\\n      exit-code: 0\\n      exit-level: info\\n      dockle-ignores: CIS-DI-0001,DKL-DI-0006\\n</code></pre>\\n","tags":["check","security","dockle","vulnerabilities","misconfigurations","secrets"],"containerImage":"euryecetelecom/woodpeckerci-kubernetes","containerImageUrl":"https://hub.docker.com/r/euryecetelecom/woodpeckerci-kubernetes","verified":false}]')}}]);